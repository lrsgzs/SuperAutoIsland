using System.Net;
using System.Net.WebSockets;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using SuperAutoIsland.Interface.Shared;
using SuperAutoIsland.Shared;

namespace SuperAutoIsland.Server;

public class SaiServer
{
    public readonly Dictionary<string, RegisterData> ExtraBlocks = new();
    private bool _isRunning;
    
    public readonly string Url;
    private readonly HttpListener _listener;
    private readonly string _wwwRoot;
    
    public SaiServer(string port)
    {
        Url = $"http://localhost:{port}/";
        _wwwRoot = Path.Combine(GlobalConstants.PluginFolder!, "assets", "wwwroot");
        _isRunning = true;
        
        _listener = new HttpListener();
        _listener.Prefixes.Add(Url);
        _listener.Start();
    }

    public async Task Serve()
    {
        while (_isRunning)
        {
            try
            {
                var context = await _listener.GetContextAsync();
                if (context.Request.IsWebSocketRequest)
                {
                    // WebSocket请求
                    await HandleWebSocketAsync(context);
                }
                else
                {
                    // 静态文件请求
                    await ServeStaticFileAsync(context);
                }
            }
            catch (HttpListenerException ex) when (ex.ErrorCode == 995) {
                Console.WriteLine("呃呃呃啊哦呃，服务器已经关了呢喵...");
            }
            catch (Exception ex) {
                Console.WriteLine($"[SuperAutoIsland.Server] 监听过程中发生错误: {ex.Message}");
            }
        }
    }

    public void Shutdown()
    {
        Console.WriteLine("开始关闭服务器...");
        _isRunning = false;
        if (_listener.IsListening) {
            _listener.Stop();
            _listener.Close();
        }
        GC.SuppressFinalize(this);
    }
    
    // Generated by DeepSeek（
    
    // 处理WebSocket连接
    private static async Task HandleWebSocketAsync(HttpListenerContext context)
    {
        WebSocketContext wsContext = await context.AcceptWebSocketAsync(null);
        WebSocket websocket = wsContext.WebSocket;
        Console.WriteLine($"WebSocket连接已建立: {context.Request.RemoteEndPoint}");

        try
        {
            var buffer = new byte[1024];
            while (websocket.State == WebSocketState.Open)
            {
                var result = await websocket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
                if (result.MessageType == WebSocketMessageType.Close)
                {
                    await websocket.CloseAsync(WebSocketCloseStatus.NormalClosure, null, CancellationToken.None);
                    Console.WriteLine("WebSocket连接关闭");
                }
                else
                {
                    var message = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    Console.WriteLine($"收到消息: {message}");
                    
                    // 回显消息
                    var response = $"服务器回复: {DateTime.Now:HH:mm:ss} - {message}";
                    var responseBytes = Encoding.UTF8.GetBytes(response);
                    await websocket.SendAsync(
                        new ArraySegment<byte>(responseBytes),
                        WebSocketMessageType.Text,
                        true,
                        CancellationToken.None);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"WebSocket错误: {ex.Message}");
        }
    }

    // 处理静态文件请求
    private async Task ServeStaticFileAsync(HttpListenerContext context)
    {
        try
        {
            var path = context.Request.Url!.LocalPath.TrimStart('/');
            path = string.IsNullOrEmpty(path) ? "index.html" : path;
            var fullPath = Path.Combine(_wwwRoot, path);

            if (File.Exists(fullPath))
            {
                var content = await File.ReadAllBytesAsync(fullPath);
                context.Response.ContentType = GetMimeType(Path.GetExtension(fullPath));
                context.Response.ContentLength64 = content.Length;
                await context.Response.OutputStream.WriteAsync(content, 0, content.Length);
                Console.WriteLine($"已发送文件: {path}");
            }
            else
            {
                context.Response.StatusCode = 404;
                var notFound = "File Not Found"u8.ToArray();
                await context.Response.OutputStream.WriteAsync(notFound, 0, notFound.Length);
                Console.WriteLine($"文件未找到: {path}");
            }
        }
        catch (Exception ex)
        {
            context.Response.StatusCode = 500;
            var error = Encoding.UTF8.GetBytes($"Server Error: {ex.Message}");
            await context.Response.OutputStream.WriteAsync(error, 0, error.Length);
            Console.WriteLine($"文件处理错误: {ex.Message}");
        }
        finally
        {
            context.Response.Close();
        }
    }

    // 获取MIME类型
    private static string GetMimeType(string extension) => extension.ToLower() switch
    {
        ".html" => "text/html",
        ".js" => "application/javascript",
        ".css" => "text/css",
        ".png" => "image/png",
        ".jpg" or ".jpeg" => "image/jpeg",
        ".gif" => "image/gif",
        ".json" => "application/json",
        _ => "application/octet-stream"
    };
    
    private string GenerateExtraBlocksJson()
    {
        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
            Converters = 
            {
                new MetaArgsConverter(),  // 处理多态参数
                new TupleConverter(),     // 处理元组
                new JsonStringEnumConverter() // 处理枚举
            }
        };
        
        return JsonSerializer.Serialize(ExtraBlocks, options);
    }
}